# Azure DevOps Pipeline for AKS Deployment
# This pipeline builds Docker images and deploys to Azure Kubernetes Service (AKS)
trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - '*.md'
      - 'docs/*'

variables:
  - name: ACR_NAME
    value: 'eteliosacr'
  - name: ACR_LOGIN_SERVER
    value: 'eteliosacr-hvawabdbgge7e0fu.azurecr.io'
  - name: AKS_RESOURCE_GROUP
    value: 'Etelios-AKS-RG'
  - name: AKS_CLUSTER_NAME
    value: 'Etelios-AKS'
  - name: NAMESPACE
    value: 'etelios-backend-prod'
  - name: IMAGE_TAG
    value: '$(Build.BuildId)'

stages:
- stage: Build
  displayName: 'Build and Push Docker Images'
  jobs:
  - job: BuildImages
    displayName: 'Build All Service Images'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: Bash@3
      displayName: 'Initial Disk Cleanup'
      inputs:
        targetType: 'inline'
        script: |
          echo "üßπ AGGRESSIVE DISK CLEANUP - Starting..."
          
          # Check disk space and fail if too low
          echo "üìä Checking initial disk space..."
          DISK_USAGE=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
          AVAILABLE_GB=$(df -BG / | tail -1 | awk '{print $4}' | sed 's/G//')
          
          echo "Disk usage: ${DISK_USAGE}%"
          echo "Available space: ${AVAILABLE_GB}GB"
          
          # Fail if disk usage is above 90% or less than 5GB available
          if [ "$DISK_USAGE" -gt 90 ] || [ "$AVAILABLE_GB" -lt 5 ]; then
            echo "‚ùå ERROR: Disk space critically low!"
            echo "   Usage: ${DISK_USAGE}%"
            echo "   Available: ${AVAILABLE_GB}GB"
            echo "   Performing emergency cleanup..."
            
            # Emergency cleanup
            docker system prune -af --volumes 2>/dev/null || true
            docker builder prune -af 2>/dev/null || true
            sudo find /var/log -type f -name "*.log" -delete 2>/dev/null || true
            sudo find /tmp -type f -delete 2>/dev/null || true
            
            # Recheck
            DISK_USAGE=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
            AVAILABLE_GB=$(df -BG / | tail -1 | awk '{print $4}' | sed 's/G//')
            echo "After cleanup - Usage: ${DISK_USAGE}%, Available: ${AVAILABLE_GB}GB"
            
            if [ "$DISK_USAGE" -gt 90 ] || [ "$AVAILABLE_GB" -lt 5 ]; then
              echo "‚ùå ERROR: Still insufficient disk space after cleanup!"
              exit 1
            fi
          fi
          
          # Show initial disk space
          echo "üìä Initial disk usage:"
          df -h / || echo "‚ö†Ô∏è  Could not check disk usage"
          
          # Clean up system logs and temporary files
          echo "Cleaning system logs and temp files..."
          sudo find /var/log -type f -name "*.log" -mtime +0 -delete 2>/dev/null || true
          sudo find /tmp -type f -mtime +0 -delete 2>/dev/null || true
          sudo find /home/vsts -type f -name "*.log" -mtime +0 -delete 2>/dev/null || true
          
          # Clean up Docker aggressively
          echo "Cleaning Docker system..."
          docker system prune -af --volumes --filter "until=1h" 2>/dev/null || true
          docker builder prune -af --filter "until=1h" 2>/dev/null || true
          
          # Remove all stopped containers
          docker container prune -f 2>/dev/null || true
          
          # Remove all unused images (not just dangling)
          docker image prune -af --filter "until=1h" 2>/dev/null || true
          
          # Clean up Docker build cache
          docker builder prune -af 2>/dev/null || true
          
          # Clean up Azure CLI cache
          echo "Cleaning Azure CLI cache..."
          az cache purge 2>/dev/null || true
          rm -rf ~/.azure/logs/* 2>/dev/null || true
          
          # Clean up npm/node cache if exists
          npm cache clean --force 2>/dev/null || true
          
          # Clean up pip cache if exists
          pip cache purge 2>/dev/null || true
          
          # Show disk space after cleanup
          echo "üìä Disk usage after cleanup:"
          df -h / || echo "‚ö†Ô∏è  Could not check disk usage"
          
          echo "‚úÖ Initial cleanup complete"
    
    - task: AzureCLI@2
      displayName: 'Clean Docker Cache and Build/Push All Images'
      inputs:
        azureSubscription: 'Azure-Service-Connection'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Set variables
          ACR_NAME="$(ACR_NAME)"
          ACR_LOGIN_SERVER="$(ACR_LOGIN_SERVER)"
          IMAGE_TAG="$(IMAGE_TAG)"
          
          # Additional Docker cleanup before starting
          echo "üßπ Pre-build Docker cleanup..."
          docker system prune -af --volumes --filter "until=30m" 2>/dev/null || true
          docker builder prune -af --filter "until=30m" 2>/dev/null || true
          
          # Show disk space
          echo "üìä Current disk usage:"
          df -h / || echo "‚ö†Ô∏è  Could not check disk usage"
          
          # Verify Azure CLI is authenticated
          echo "Verifying Azure CLI authentication..."
          az account show || {
            echo "‚ùå Error: Azure CLI is not authenticated"
            exit 1
          }
          echo "‚úÖ Azure CLI authenticated"
          
          # Verify ACR exists and is accessible
          echo "Verifying ACR access: $ACR_NAME"
          az acr show --name $ACR_NAME --query name -o tsv || {
            echo "‚ùå Error: Cannot access ACR $ACR_NAME"
            echo "Please verify:"
            echo "  1. ACR name is correct: $ACR_NAME"
            echo "  2. Service principal has 'Reader' role on ACR"
            exit 1
          }
          echo "‚úÖ ACR is accessible"
          
          # Login to ACR using Azure CLI
          echo "Logging in to ACR: $ACR_NAME"
          az acr login --name $ACR_NAME || {
            echo "‚ùå Error: Failed to login to ACR"
            echo "Please verify service principal has 'AcrPush' role on ACR"
            echo "Grant permission with:"
            echo "  az role assignment create --assignee <service-principal-id> --role AcrPush --scope /subscriptions/<sub-id>/resourceGroups/<rg>/providers/Microsoft.ContainerRegistry/registries/$ACR_NAME"
            exit 1
          }
          echo "‚úÖ Successfully logged in to ACR: $ACR_LOGIN_SERVER"
          
          # Test ACR access by listing repositories
          echo "Testing ACR push permissions..."
          az acr repository list --name $ACR_NAME --output table || echo "‚ö†Ô∏è  Warning: Cannot list repositories, but push may still work"
          
          # Build and push API Gateway
          echo "Building and pushing API Gateway..."
          docker build --rm --no-cache -t $ACR_LOGIN_SERVER/api-gateway:$IMAGE_TAG -t $ACR_LOGIN_SERVER/api-gateway:latest -f Dockerfile .
          docker push $ACR_LOGIN_SERVER/api-gateway:$IMAGE_TAG
          docker push $ACR_LOGIN_SERVER/api-gateway:latest
          echo "‚úÖ API Gateway pushed successfully"
          
          # Clean up local API Gateway image after push to save space
          echo "Cleaning up local API Gateway image..."
          docker rmi $ACR_LOGIN_SERVER/api-gateway:$IMAGE_TAG $ACR_LOGIN_SERVER/api-gateway:latest 2>/dev/null || true
          
          # Clean up build cache after each major build
          docker builder prune -af --filter "until=10m" 2>/dev/null || true
    
          # Build and push all microservices
          SERVICES=(
            "auth-service"
            "hr-service"
            "attendance-service"
            "payroll-service"
            "crm-service"
            "inventory-service"
            "sales-service"
            "purchase-service"
            "financial-service"
            "document-service"
            "service-management"
            "cpp-service"
            "prescription-service"
            "analytics-service"
            "notification-service"
            "monitoring-service"
            "tenant-registry-service"
            "realtime-service"
          )
          
          SERVICE_COUNT=0
          for SERVICE in "${SERVICES[@]}"; do
            SERVICE_COUNT=$((SERVICE_COUNT + 1))
            echo "Building and pushing $SERVICE ($SERVICE_COUNT/${#SERVICES[@]})..."
            
            # Build without cache to save disk space (images are pushed immediately)
            docker build --rm --no-cache -t $ACR_LOGIN_SERVER/$SERVICE:$IMAGE_TAG -t $ACR_LOGIN_SERVER/$SERVICE:latest -f microservices/$SERVICE/Dockerfile microservices/$SERVICE/
            docker push $ACR_LOGIN_SERVER/$SERVICE:$IMAGE_TAG
            docker push $ACR_LOGIN_SERVER/$SERVICE:latest
            echo "‚úÖ $SERVICE pushed successfully"
            
            # Clean up local image immediately after push to save space
            echo "Cleaning up local image for $SERVICE..."
            docker rmi $ACR_LOGIN_SERVER/$SERVICE:$IMAGE_TAG $ACR_LOGIN_SERVER/$SERVICE:latest 2>/dev/null || true
            
            # Clean up build cache every 3 services to prevent disk fill
            if [ $((SERVICE_COUNT % 3)) -eq 0 ]; then
              echo "üßπ Periodic cleanup after $SERVICE_COUNT services..."
              docker builder prune -af --filter "until=10m" 2>/dev/null || true
              docker system prune -f --filter "until=10m" 2>/dev/null || true
              echo "üìä Disk usage after $SERVICE_COUNT services:"
              df -h / | head -2 || echo "‚ö†Ô∏è  Could not check disk usage"
            fi
          done
          
          # Final aggressive cleanup of Docker cache
          echo "üßπ Final aggressive Docker cache cleanup..."
          docker system prune -af --volumes --filter "until=1h" 2>/dev/null || true
          docker builder prune -af --filter "until=1h" 2>/dev/null || true
          docker container prune -f 2>/dev/null || true
          docker image prune -af --filter "until=1h" 2>/dev/null || true
          
          # Clean up any remaining temporary files
          echo "Cleaning up temporary files..."
          find /tmp -type f -mtime +0 -delete 2>/dev/null || true
          find ~/.azure/logs -type f -mtime +0 -delete 2>/dev/null || true
          
          # Show final disk space
          echo "üìä Final disk usage:"
          df -h / || echo "‚ö†Ô∏è  Could not check disk usage"
          
          echo "‚úÖ All images built and pushed successfully"

- stage: Deploy
  displayName: 'Deploy to AKS'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: DeployToAKS
    displayName: 'Deploy to AKS Cluster'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'etelios-aks-production'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'Configure kubectl for AKS'
            inputs:
              azureSubscription: 'Azure-Service-Connection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Set variables
                AKS_RESOURCE_GROUP="$(AKS_RESOURCE_GROUP)"
                AKS_CLUSTER_NAME="$(AKS_CLUSTER_NAME)"
                
                # Verify Azure CLI is authenticated
                echo "Verifying Azure CLI authentication..."
                az account show || {
                  echo "‚ùå Error: Azure CLI is not authenticated"
                  exit 1
                }
                echo "‚úÖ Azure CLI authenticated"
                
                # Get AKS credentials to configure kubectl
                echo "Configuring kubectl for AKS cluster: $AKS_CLUSTER_NAME"
                az aks get-credentials \
                  --resource-group $AKS_RESOURCE_GROUP \
                  --name $AKS_CLUSTER_NAME \
                  --overwrite-existing || {
                  echo "‚ùå Error: Failed to get AKS credentials"
                  exit 1
                }
                echo "‚úÖ kubectl configured for AKS cluster"
                
                # Verify kubectl connection
                echo "Verifying kubectl connection..."
                kubectl version --client
                kubectl cluster-info || {
                  echo "‚ö†Ô∏è  Warning: Could not get cluster info, but connection may still work"
                }
                kubectl get nodes || {
                  echo "‚ö†Ô∏è  Warning: Could not get nodes, but connection may still work"
                }
          
          - task: Bash@3
            displayName: 'Generate Kubernetes Manifests (if needed)'
            inputs:
              targetType: 'inline'
              script: |
                # Check if generate-manifests.sh exists and manifests need to be generated
                if [ -f "k8s/generate-manifests.sh" ]; then
                  echo "Generating Kubernetes manifests..."
                  chmod +x k8s/generate-manifests.sh
                  export ACR_NAME=$(ACR_NAME)
                  export IMAGE_TAG=$(IMAGE_TAG)
                  export NAMESPACE=$(NAMESPACE)
                  ./k8s/generate-manifests.sh
                  echo "‚úÖ Manifests generated successfully"
                elif [ -d "k8s/deployments" ] && [ "$(ls -A k8s/deployments/*.yaml 2>/dev/null)" ]; then
                  echo "‚úÖ Using existing manifests in k8s/deployments/"
                  echo "Manifests found:"
                  ls -la k8s/deployments/*.yaml
                else
                  echo "‚ö†Ô∏è  Warning: No generate-manifests.sh found and no existing manifests"
                  echo "Manifests should already exist in k8s/deployments/"
                fi
                
                # Verify required manifests exist
                echo "Verifying required manifests..."
                if [ ! -f "k8s/namespace.yaml" ]; then
                  echo "‚ùå Error: k8s/namespace.yaml not found"
                  exit 1
                fi
                if [ ! -f "k8s/configmap.yaml" ]; then
                  echo "‚ùå Error: k8s/configmap.yaml not found"
                  exit 1
                fi
                if [ ! -f "k8s/api-gateway.yaml" ]; then
                  echo "‚ùå Error: k8s/api-gateway.yaml not found"
                  exit 1
                fi
                if [ ! -d "k8s/deployments" ]; then
                  echo "‚ùå Error: k8s/deployments directory not found"
                  exit 1
                fi
                echo "‚úÖ All required manifests verified"
          
          - task: Kubernetes@1
            displayName: 'Create Namespace'
            inputs:
              connectionType: 'kubernetesServiceConnection'
              kubernetesServiceEndpoint: 'AKS-Service-Connection'
              namespace: '$(NAMESPACE)'
              command: 'apply'
              arguments: '-f k8s/namespace.yaml'
              secretType: 'generic'
          
          - task: Kubernetes@1
            displayName: 'Apply ConfigMap'
            inputs:
              connectionType: 'kubernetesServiceConnection'
              kubernetesServiceEndpoint: 'AKS-Service-Connection'
              namespace: '$(NAMESPACE)'
              command: 'apply'
              arguments: '-f k8s/configmap.yaml'
              secretType: 'generic'
          
          - task: Kubernetes@1
            displayName: 'Apply Secrets'
            inputs:
              connectionType: 'kubernetesServiceConnection'
              kubernetesServiceEndpoint: 'AKS-Service-Connection'
              namespace: '$(NAMESPACE)'
              command: 'apply'
              arguments: '-f k8s/secrets.yaml'
              secretType: 'generic'
          
          - task: Kubernetes@1
            displayName: 'Deploy API Gateway'
            inputs:
              connectionType: 'kubernetesServiceConnection'
              kubernetesServiceEndpoint: 'AKS-Service-Connection'
              namespace: '$(NAMESPACE)'
              command: 'apply'
              arguments: '-f k8s/api-gateway.yaml'
              secretType: 'generic'
          
          - task: Kubernetes@1
            displayName: 'Deploy All Microservices'
            inputs:
              connectionType: 'kubernetesServiceConnection'
              kubernetesServiceEndpoint: 'AKS-Service-Connection'
              namespace: '$(NAMESPACE)'
              command: 'apply'
              arguments: '-f k8s/deployments/'
              secretType: 'generic'
          
          - task: Kubernetes@1
            displayName: 'Apply Ingress'
            inputs:
              connectionType: 'kubernetesServiceConnection'
              kubernetesServiceEndpoint: 'AKS-Service-Connection'
              namespace: '$(NAMESPACE)'
              command: 'apply'
              arguments: '-f k8s/ingress.yaml'
              secretType: 'generic'
          
          - task: Bash@3
            displayName: 'Wait for Deployments'
            inputs:
              targetType: 'inline'
              script: |
                kubectl wait --for=condition=available --timeout=300s deployment --all -n $(NAMESPACE) || true
                kubectl get deployments -n $(NAMESPACE)
                kubectl get services -n $(NAMESPACE)
                kubectl get ingress -n $(NAMESPACE)
